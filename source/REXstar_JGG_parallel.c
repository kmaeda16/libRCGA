#define _USE_MATH_DEFINES
#define INIT_VALUE (-1e+10)
#define DISMISSING_SIGNAL (-1e+20)
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <float.h>
#include "mpi.h"
#include "REXstar_JGG_parallel.h"


void RCGA(RCGAParam *Param, Chromosome **Population, Chromosome *best, time_t *t0)
{
	int i, index;
	int n_population, n_gene, n_constraint, n_generation, output_intvl;
	double allowable_error;
	long t_limit;
	char *out_transition;
	DecodingFun decodingfun;
	int flg_printed = 0;
	
	if(Param->my_rank > 0){
		calcFitness4Master(Param);
		return;
	}

	n_population = Param->n_population;
	n_gene = Param->n_gene;
	n_constraint = Param->n_constraint;
	n_generation = Param->n_generation;
	output_intvl = Param->output_intvl;
	allowable_error = Param->allowable_error;
	t_limit = Param->t_limit;
	out_transition = Param->out_transition;
	decodingfun = Param->decodingfun;

	i = 1;
	InitPopulation(Param,Population);
	index = findBest(Population,n_population);
	copyChrom(best,Population[index],n_gene,n_constraint);

	if(0 < output_intvl){
		printTransition(t0,i,best->f,best->phi);
		writeTransition(t0,i,out_transition,best,n_gene,n_constraint,decodingfun);
		flg_printed = 1;
	}
	if( (best->phi == 0 && best->f <= allowable_error) || getElapsedTime(t0) >= t_limit ) goto end;
	
	while(i < n_generation){
		i++;
		flg_printed = 0;
		JGG(Param,Population);
		index = findBest(Population,n_population);
		if( Population[index]->phi < best->phi 
			|| (Population[index]->phi == best->phi && Population[index]->f < best->f) )
			copyChrom(best,Population[index],n_gene,n_constraint);
		if(0 < output_intvl && i % output_intvl == 0){
			printTransition(t0,i,best->f,best->phi);
			writeTransition(t0,i,out_transition,best,n_gene,n_constraint,decodingfun);
			flg_printed = 1;
		}
		if( (best->phi == 0 && best->f <= allowable_error) || getElapsedTime(t0) >= t_limit ) goto end;
	}

end:
	if(0 < output_intvl && flg_printed == 0){
		printTransition(t0,i,best->f,best->phi);
		writeTransition(t0,i,out_transition,best,n_gene,n_constraint,decodingfun);
	}
	dismissWorkers(Param);

	return;
}


void JGG(RCGAParam *Param, Chromosome **Population)
{
	/*
	Just Generation Gap Selection for REXstar
	This function alters population using JGG with REXstar.

	See "Kimura S, Sato M, Okada-Hatakeyama M: An Effective Method for the 
	Inference of Reduced S-system Models of Genetic Networks. Information and 
	Media Technologies 2015, 10(1):166-174.".
	*/

	const int maxitr = 10;
	int *ip;
	Chromosome **p, **c, **f;
	int n_parent, n_children, n_gene, n_constraint, n_population, selection_type;
	int flg;
	int i, j, k;
	double Pf;

	n_parent = Param->n_parent;
	n_children = Param->n_children;
	n_gene = Param->n_gene;
	n_constraint = Param->n_constraint;
	n_population = Param->n_population;
	selection_type = Param->selection_type;
	Pf = Param->Pf;

	ip = allocIVector(n_parent);
	p = allocPopulation(n_parent,n_gene,n_constraint);
	c = allocPopulation(n_children,n_gene,n_constraint);

	// Pick up parents from main population
	for(i=1; i<=n_parent; i++){
		for(j=1; j<=maxitr; j++){
			flg = 0;
			ip[i] = (int)(Rand()*(double)n_population) + 1;
			for(k=1; k<i; k++){
				if(ip[k] == ip[i]) flg = 1;
			}
			if(flg == 0) break;
		}
	
	}
	for(i=1; i<=n_parent; i++) copyChrom(p[i],Population[ip[i]],n_gene,n_constraint);

	REXstar(Param,p,c);

	switch(selection_type){
		case 0:
			// Chosen from children (Kobayashi, 2009)
			for(i=1; i<=n_parent; i++) copyChrom(Population[ip[i]],c[i],n_gene,n_constraint);
			break;
		case 1:
			// Chosen from family (Kimura et al., 2015)
			f = allocPopulation(n_parent+n_children,n_gene,n_constraint);
			for(i=1; i<=n_parent; i++) copyChrom(f[i],p[i],n_gene,n_constraint);
			for(i=1; i<=n_children; i++) copyChrom(f[n_parent+i],c[i],n_gene,n_constraint);
			sort(f,n_parent+n_children,n_gene,n_constraint,Pf);
			for(i=1; i<=n_parent; i++) copyChrom(Population[ip[i]],f[i],n_gene,n_constraint);
			freePopulation(f,n_parent+n_children,n_gene,n_constraint);
			break;
		default:
			handleError("Unexpected selection_type!");
			exit(0);
	}
	sort(Population,n_population,n_gene,n_constraint,Pf);

	freePopulation(p,n_parent,n_gene,n_constraint);
	freePopulation(c,n_children,n_gene,n_constraint);
	freeIVector(ip,n_parent);

	return;
}


void REXstar(RCGAParam *Param, Chromosome **p, Chromosome **c)
{
	/*
	Function of REXstar (Real-coded Ensemble Crossover star)
	This function returns children generated by REXstar.

	See "Kimura S, Sato M, Okada-Hatakeyama M: An Effective Method for the 
	Inference of Reduced S-system Models of Genetic Networks. Information and 
	Media Technologies 2015, 10(1):166-174.".

	Recommended:
	n_population = 2*n_gene ~ 20*n_gene
	n_parent = n_gene + 1
	n_children = 2*n_gene ~ 3*n_gene
	t (Step-size parameter) = 2.5 ~ 15

	Required:
	n_parent <= n_children
	*/

	const int maxitr = 100;
	Chromosome *G, *Gb;
	Chromosome **r;
	Chromosome **temp;
	double xi;
	int flg_oob, flg_eval;
	int *flgs_calcFitness;
	int count;
	int i, j, k, l;
	int n_gene, n_parent, n_children, n_constraint;
	double t;
	double Pf;

	n_gene = Param->n_gene;
	n_parent = Param->n_parent;
	n_children = Param->n_children;
	n_constraint = Param->n_constraint;
	t = Param->t_rexstar;
	Pf = Param->Pf;

	flgs_calcFitness = allocIVector(n_children);

	if(n_children < n_parent){
		handleError("n_parent <= n_children must be satisfied!\n");
		exit(0);
	}
	
	// Calculate center of gravity G
	G = allocChrom(n_gene,n_constraint);
	for(j=1; j<=n_gene; j++) G->gene[j] = 0.0;
	G->f = G->phi = DBL_MAX;
	for(i=1; i<=n_parent; i++){
		for(j=1; j<=n_gene; j++) G->gene[j] += p[i]->gene[j];
	}
	for(j=1; j<=n_gene; j++) G->gene[j] /= (double)n_parent;

	// Initialize children
	for(i=1; i<=n_children; i++){
		for(j=1; j<=n_gene; j++) c[i]->gene[j] = DBL_MAX;
		c[i]->f = c[i]->phi = DBL_MAX;
	}

	// Calculate reflection points (which are treated as the children)
	for(i=1; i<=n_parent; i++){
		for(j=1; j<=n_gene; j++) c[i]->gene[j] = 2.0 * G->gene[j] - p[i]->gene[j];
		flg_oob = 0;
		for(j=1; j<=n_gene; j++){
			if(c[i]->gene[j] < 0.0 || 1.0 < c[i]->gene[j]) flg_oob = 1;
		}
		flgs_calcFitness[i] = 0;
		if(flg_oob == 0){
			flgs_calcFitness[i] = 1; // setFitness(c[i],Param->n_gene,Param->n_constraint,Param->fitnessfun,Param->decodingfun);
		}else{
			c[i]->f = c[i]->phi = DBL_MAX;
		}
	}
	
	/* --- Fitness calculation ---------------- */
	temp = allocPopulation(n_children,n_gene,n_constraint);
	count = 0;
	for(i=1; i<=n_parent; i++){
		if(flgs_calcFitness[i] == 1){
			count++;
			copyChrom(temp[count],c[i],n_gene,n_constraint);
		}
	}
	requestFitnessCalc(Param,temp,count);
	count = 0;
	for(i=1; i<=n_parent; i++){
		if(flgs_calcFitness[i] == 1){
			count++;
			copyChrom(c[i],temp[count],n_gene,n_constraint);
		}
	}
	freePopulation(temp,n_children,n_gene,n_constraint);
	/* ---------------------------------------- */

	// Store parents and refrection points
	r = allocPopulation(2*n_parent,n_gene,n_constraint);
	for(i=1; i<=n_parent; i++){
		copyChrom(r[i],p[i],n_gene,n_constraint);
		copyChrom(r[n_parent+i],c[i],n_gene,n_constraint);
	}
	sort(r,2*n_parent,n_gene,n_constraint,Pf);
	
	// Calculate center of gravity Gb
	Gb = allocChrom(n_gene,n_constraint);
	for(j=1; j<=n_gene; j++) Gb->gene[j] = 0.0;
	Gb->f = Gb->phi = DBL_MAX;
	for(i=1; i<=n_parent; i++){
		for(j=1; j<=n_gene; j++) Gb->gene[j] += r[i]->gene[j];
	}
	for(j=1; j<=n_gene; j++) Gb->gene[j] /= (double)n_parent;

	// Generate children
	for(i=1; i<=n_children; i++){
		flg_eval = 0;
		// If the generated child is out of range, re-generate a child
		for(l=0; l<maxitr; l++){
			flg_oob = 0;
			for(j=1; j<=n_gene; j++){
				if(c[i]->gene[j] < 0.0 || 1.0 < c[i]->gene[j]) flg_oob = 1;
			}
			if(flg_oob == 0) break;
			// Generation
			for(j=1; j<=n_gene; j++) c[i]->gene[j] = G->gene[j];
			for(j=1; j<=n_gene; j++){
				xi = t * Rand();
				c[i]->gene[j] += xi * (Gb->gene[j] - G->gene[j]);
			}
			for(k=1; k<=n_parent; k++){
				xi = 2.0 * sqrt(3.0/((double)n_parent)) * Rand() - sqrt(3.0/((double)n_parent));
				for(j=1; j<=n_gene; j++) c[i]->gene[j] += xi * (p[k]->gene[j] - G->gene[j]);
			}
			flg_eval = 1;
		}
		// If the generated child is out of range, alter the child
		if(flg_oob == 1){
			for(j=1; j<=n_gene; j++){
				if(1.0 < c[i]->gene[j]){
					c[i]->gene[j] = 1.0;
				}else if(c[i]->gene[j] < 0.0){
					c[i]->gene[j] = 0.0;
				}
			}
			flg_eval = 1;
		}
		flgs_calcFitness[i] = 0;
		if(flg_eval == 1) flgs_calcFitness[i] = 1; //setFitness(SearchRegion,&c[i],n_gene,n_constraint);
	}
	
	/* --- Fitness calculation ---------------- */
	temp = allocPopulation(n_children,n_gene,n_constraint);
	count = 0;
	for(i=1; i<=n_children; i++){
		if(flgs_calcFitness[i] == 1){
			count++;
			copyChrom(temp[count],c[i],n_gene,n_constraint);
		}
	}
	requestFitnessCalc(Param,temp,count);
	count = 0;
	for(i=1; i<=n_children; i++){
		if(flgs_calcFitness[i] == 1){
			count++;
			copyChrom(c[i],temp[count],n_gene,n_constraint);
		}
	}
	freePopulation(temp,n_children,n_gene,n_constraint);
	/* ---------------------------------------- */

	sort(c,n_children,n_gene,n_constraint,Pf);

	freeIVector(flgs_calcFitness,n_children);
	freeChrom(G,n_gene,n_constraint);
	freeChrom(Gb,n_gene,n_constraint);
	freePopulation(r,2*n_parent,n_gene,n_constraint);

	return;
}


void RCGAInitial(int *argc, char ***argv, int seed, int n_gene, int n_generation, int n_population,
	int n_parent, int n_children, double t_rexstar, int selection_type, double allowable_error, long t_limit,
	int n_constraint, double Pf, int output_intvl, char *out_transition, char *out_solution, char *out_population,
	FitnessFun fitnessfun, DecodingFun decodingfun,
	RCGAParam **Param, Chromosome ***Population, Chromosome **best, time_t **t0)
{
	int my_rank, n_ps;
	
	MPI_Init(argc, argv);
	MPI_Comm_rank(MPI_COMM_WORLD, &my_rank);
	MPI_Comm_size(MPI_COMM_WORLD, &n_ps);

	if (n_ps < 2) handleError("Error in RCGAInitial: # processes must be > 1!");
	
	srand(seed);

	(*Param) = (RCGAParam *)malloc((size_t)sizeof(RCGAParam));
	(*Param)->my_rank = my_rank;
	(*Param)->n_ps = n_ps;
	(*Param)->n_gene = n_gene;
	(*Param)->n_generation = n_generation;
	(*Param)->n_population = n_population;
	(*Param)->n_parent = n_parent;
	(*Param)->n_children = n_children;
	(*Param)->t_rexstar = t_rexstar;
	(*Param)->selection_type = selection_type;
	(*Param)->allowable_error = allowable_error;
	(*Param)->t_limit = t_limit;
	(*Param)->n_constraint = n_constraint;
	(*Param)->Pf = Pf;
	(*Param)->output_intvl = output_intvl;
	(*Param)->out_transition = out_transition;
	(*Param)->out_solution = out_solution;
	(*Param)->out_population = out_population;
	(*Param)->fitnessfun = fitnessfun;
	(*Param)->decodingfun = decodingfun;

	if (my_rank == 0) {
		(*Population) = allocPopulation(n_population, n_gene, n_constraint);
		(*best) = allocChrom(n_gene,n_constraint);
		(*t0) = (time_t *)malloc((size_t)sizeof(time_t));
		(**t0) = time(NULL);
	}

	return;
}


void RCGADeInitial(RCGAParam *Param, Chromosome **Population, Chromosome *best, time_t *t0)
{
	int my_rank;
	int n_population, n_gene, n_constraint;
	char *out_solution, *out_population;
	DecodingFun decodingfun;

	my_rank = Param->my_rank;
	n_population = Param->n_population;
	n_gene = Param->n_gene;
	n_constraint = Param->n_constraint;
	out_solution = Param->out_solution;
	out_population = Param->out_population;
	decodingfun = Param->decodingfun;

	if(my_rank == 0){
		writePopulation(out_population,Population,n_population,n_gene,n_constraint,decodingfun);
		writeSolution(t0,out_solution,best,n_gene,n_constraint,decodingfun);
		printElapsedTime(t0);
		free(t0);
		freePopulation(Population, n_population, n_gene, n_constraint);
		freeChrom(best,n_gene,n_constraint);
	}
	free(Param);

	MPI_Finalize();
	return;
}


void InitPopulation(RCGAParam *Param, Chromosome **Population)
{
	int i, j;

	for( i=1; i<=Param->n_population; i++ ){
		for( j=1; j<=Param->n_gene; j++ ) Population[i]->gene[j] = Rand();
		// setFitness(Population[i],Param->n_gene,Param->n_constraint,Param->fitnessfun,Param->decodingfun);
	}
	requestFitnessCalc(Param,Population, Param->n_population);
	sort(Population,Param->n_population,Param->n_gene,Param->n_constraint,Param->Pf);
}


void requestFitnessCalc(RCGAParam *Param, Chromosome **Group, int n_group)
{
	MPI_Status status;
	double *buffer_send, *buffer_recv;
	int n_ps, n_gene, n_constraint, n_population, n_children, n_assignment;
	int *index;
	int count;
	int i, j, k;

	if(n_group == 0) return;

	n_ps = Param->n_ps;
	n_gene = Param->n_gene;
	n_constraint = Param->n_constraint;
	n_population = Param->n_population;
	n_children = Param->n_children;

	if(n_population > n_children){
		n_assignment = (int) ceil( (double)n_population / ((double)n_ps-1.0) );
	}else{
		n_assignment = (int) ceil( (double)n_children / ((double)n_ps-1.0) );
	}

#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
	for(j=1; j<=n_group; j++){
		printf("Group[%d]: %e\t%e:\t",j,Group[j]->f,Group[j]->phi);
		for(k=1; k<=n_gene; k++) printf("%e\t", Group[j]->gene[k]);
		for(k=1; k<=n_constraint; k++) printf("%e\t", Group[j]->g[k]);
		printf("\n");
	}
#endif /*-------------------------------------------------------------------------------------------------------------*/
	
	// index[j] has the index of process that will evaluates the j-th group
	index = allocIVector(n_group);
	for(j=1; j<=n_group; j++) index[j] = (j-1) % (n_ps-1) + 1;

	// Send some groups to workers
	buffer_send = allocDVector(n_assignment*n_gene);

	for(i=1; i<n_ps; i++){

		//	Subgroup -> buffer_send
		count = 0;
		for(j=1; j<=n_group; j++){
			if(index[j] == i){
				for(k=1; k<=n_gene; k++) buffer_send[++count] = Group[j]->gene[k];
			}
		}

#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
		for(j=1; j<=count; j++) printf("[%d] [0->%d]\tbuffer_send[%d]:\t%e\n",Param->my_rank,i,j,buffer_send[j]);
#endif /*-------------------------------------------------------------------------------------------------------------*/

		// Send
		MPI_Send(&buffer_send[1], count, MPI_DOUBLE, i, 0,MPI_COMM_WORLD);

	}
	freeDVector(buffer_send,n_assignment*n_gene);

	// Receive some groups from workers
	buffer_recv = allocDVector(n_assignment*(n_constraint+2));
	for(i=1; i<n_ps; i++){

		// Receive
		MPI_Recv(&buffer_recv[1], n_assignment*(n_constraint+2), MPI_DOUBLE, i, 0, MPI_COMM_WORLD, &status);

#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
		for(j=1; j<=n_assignment*(n_constraint+2); j++) printf("[%d] [%d->0]\tbuffer_recv[%d]:\t%e\n",Param->my_rank,i,j,buffer_recv[j]);
#endif /*-------------------------------------------------------------------------------------------------------------*/

		// buffer_recv -> Group
		count = 0;
		for(j=1; j<=n_group; j++){
			if(index[j] == i){
				Group[j]->f = buffer_recv[++count];
				for(k=1; k<=n_constraint; k++) Group[j]->g[k] = buffer_recv[++count];
				Group[j]->phi = buffer_recv[++count];
			}
		}

	}
	freeDVector(buffer_recv,n_assignment*(n_constraint+2));

	freeIVector(index,n_group);

#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
	for(j=1; j<=n_group; j++){
		printf("Group[%d]: %e\t%e:\t",j,Group[j]->f,Group[j]->phi);
		for(k=1; k<=n_gene; k++) printf("%e\t", Group[j]->gene[k]);
		for(k=1; k<=n_constraint; k++) printf("%e\t", Group[j]->g[k]);
		printf("\n");
	}
#endif /*-------------------------------------------------------------------------------------------------------------*/

}


void calcFitness4Master(RCGAParam *Param)
{
	MPI_Status status;
	Chromosome *temp;
	int count, count1, count2;
	int j, k;
	double *buffer_recv, *buffer_send;
	int n_ps, n_population, n_children, n_gene, n_constraint, n_assignment, n_evalulated;

	n_ps = Param->n_ps;
	n_population = Param->n_population;
	n_children = Param->n_children;
	n_gene = Param->n_gene;
	n_constraint = Param->n_constraint;
	
	if(n_population > n_children){
		n_assignment = (int) ceil( (double)n_population / ((double)n_ps-1.0) );
	}else{
		n_assignment = (int) ceil( (double)n_children / ((double)n_ps-1.0) );
	}

	buffer_recv = allocDVector(n_assignment*n_gene);
	buffer_send = allocDVector(n_assignment*(n_constraint+2));
	temp = allocChrom(n_gene,n_constraint);

	while(1){
		
		// Initialization
		count = 0;
		for(j=1; j<=n_assignment; j++){
			for(k=1; k<=n_gene; k++) buffer_recv[++count] = INIT_VALUE;
		}
		
		// Receive
		MPI_Recv(&buffer_recv[1], n_assignment*n_gene, MPI_DOUBLE, 0, 0, MPI_COMM_WORLD, &status);
		
#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
		for(j=1; j<=n_assignment*n_gene; j++) printf("[%d] [0->%d]\tbuffer_recv[%d]:\t%e\n",Param->my_rank,Param->my_rank,j,buffer_recv[j]);
#endif /*-------------------------------------------------------------------------------------------------------------*/

		count = 0;
		for(j=1; j<=n_assignment; j++){
			for(k=1; k<=n_constraint+2; k++) buffer_send[++count] = INIT_VALUE;
		}

		count1 = 0;
		count2 = 0;
		n_evalulated = 0;
		for(j=1; j<=n_assignment; j++){

			for(k=1; k<=n_gene; k++) temp->gene[k] = buffer_recv[++count1];

			// If dismissing signal, break from while(1)
			if(temp->gene[1] == DISMISSING_SIGNAL) goto end;

			// Fitness calculation
			if(temp->gene[1] == INIT_VALUE) break;
			setFitness(temp,n_gene,n_constraint,Param->fitnessfun,Param->decodingfun);
			n_evalulated++;

			buffer_send[++count2] = temp->f;
			for(k=1; k<=n_constraint; k++) buffer_send[++count2] = temp->g[k];
			buffer_send[++count2] = temp->phi;
		}

		// Send
#ifdef DEBUG /*-------------------------------------------------------------------------------------------------------*/
		for(j=1; j<=count2; j++) printf("[%d] [%d->0]\tbuffer_send[%d]:\t%e\n",Param->my_rank,Param->my_rank,j,buffer_send[j]);
#endif /*-------------------------------------------------------------------------------------------------------------*/

		MPI_Send(&buffer_send[1], n_evalulated*(n_constraint+2), MPI_DOUBLE, 0, 0, MPI_COMM_WORLD);
		
	}

end:
	freeDVector(buffer_recv,n_assignment*n_gene);
	freeDVector(buffer_send,n_assignment*(n_constraint+2));
	freeChrom(temp,n_gene,n_constraint);

	return;
}


void dismissWorkers(RCGAParam *Param)
{
	double dismissing_signal;
	int i;

	dismissing_signal = DISMISSING_SIGNAL;
	for(i=1; i<Param->n_ps; i++)
		MPI_Send(&dismissing_signal, 1, MPI_DOUBLE, i, 0, MPI_COMM_WORLD);

	return;
}
